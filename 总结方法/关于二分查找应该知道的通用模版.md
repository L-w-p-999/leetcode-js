---
type: 技术积累
collections: 算法
title: 二分查找应该用的通用模版
tags: [算法, JavaScript]

---

二分查找是一个非常通用的算法工具，可以在遍历的时候降低算法的复杂度来提高算法的性能，但是我一直觉得它的实用性被隐藏住了，就像🤔...高中的数学题里藏着的知识点一样，有点难找到怎么使用二分查找，什么时候可以二分查找。

首先通用的代码模版是这样的：

```javascript
let left = 0, right = n;
while (left < right) {
    let mid = Math.floor((left + right) / 2);
    if (check(mid)) {
        right = mid;
    } else {
        left = mid + 1;
    }
```

在这个代码模版中的check函数就是我们区分不同的条件下的二分查找使用：
​check函数有以下几种：

```javascript
check(i) {
    return arr[i] > target;
}
```

情景 1️⃣：找「第一个 > target」

这个是在找第一个大于我要找的目标的，这个就是今天算法中应该使用的模版。

[leetcode第2054题](https://leetcode.cn/problems/two-best-non-overlapping-events/?envType=daily-question&envId=2025-12-23)

情景 2️⃣：找「第一个 == target」

在数组中有重复元素的情况下，找到第一个等于target的元素。

```javascript
check(i) {
    return arr[i] >= target;
}
```

在此情况下必须做一个越界处理：

```javascript
if (left < n && arr[left] === target) {
    // 找到了
}
```

这是为了防止一些特殊情况下的假答案，这里的check和第一个情景下的check只差了一个等于号，因此它只是找到了第一个大于等于target的值，这在数组中有target的具体值的情况下是可以找到的，但是如果有：

```javascript
arr = [1, 3, 5, 7]
target = 4
```

这里的找到的是5，肯定和我们的要求不符合。

```javascript
arr = [1, 2, 3]
target = 10
```

在这个情况下的left会越过数组的边界，这肯定也不是我们要的。

情景 3️⃣：找「最后一个 == target」

这里的我们要找最后一个target其实就是要找***第一个大于targer的位置然后再减1***

这时我们需要先找到第一个大于target的目标

那么check函数就应该是：

```javascript
check(i) {
    return arr[i] > target;
}
```

然后让我们的pos指针指向left的前一个，再加入防越界和是否是真target的检查：

```javascript
let pos = left - 1;
if (pos >= 0 && arr[pos] === target) {
    // pos 就是最后一个 target
}
```

